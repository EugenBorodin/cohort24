## Варианты связывания компонентов:

### Вариант 1

```
class Controller {
    @Autowired
    private Service service;
}
```


### Вариант 2

* Использование конструктора

```
class Controller {
    
    private Service service;
    
    @Autowired
    public Controller(Service service) {
        this.service = servivce;
    }
}
```

### Вариант 3

* Использование конструктора без Autowired
* Потому что Spring умеет делать автосвязывание без @Autowired, только на основе конструкторе

```
class Controller {
    
    private Service service;

    public Controller(Service service) {
        this.service = servivce;
    }
}
```

### Вариант 4

* Помечаем поле как `final`
* Сделать конструктор с помощью аннотации `lombok`


```
@RequiredArgsConstructor
class Controller {
    
    private final Service service;

}
```

### Структура проекта

* `main` - основной код
  * `java` - файлы исходного java-кода
    * `controllers` - классы, отвечающие за взаимодействие по HTTP
      * `api` - интерфейсы, которые содержат только документацию и базовые аннотации Spring Web
      * `controllers` - классы, которые имплементируют API, и содержат реализации самих действий. Также взаимодействуют с сервисами.
    * `dto` - классы, которые представляют собой JSON-объекты, получаемые контроллерами или отдаваемые ими. Содержат документацию и методы для конвертации из моделей.
    * `models` - (domain, entities) - модели предметной области, сущности, которые мы храним в базе данных
    * `repositories` - репозитории, интерфейсы/классы, отвечающие за работу с базами данных
    * `serviсes` - бизнес-логика, основные алгоритмы системы. Описаны в виде интерфейсов для их легкой заменяемости в контроллерах
      * `impl` - реализации ваших сервисов (impl от `Implementation`)
    * `SimpleRestApiApplication` - точка входа в приложение, содержит main-метод
  * `resources` - ресурсы приложения
    * `http` - содержит файлы отправки HTTP-запросов
    * `application.properties` - содержит настройки приложения

### Интеграционный тест

* Тест, который, в отличие от модульного, проверяет всю связку целиком.
* `MockMvc` - позволяет отправлять запросы и проверять ответы.

### Как правильно обрабатывать ошибки?

1. Найти место, где потенциально возникает ошибка и желательно сделать проверку и выбросить свое исключение (в нашем случае RestApiException - содержит статус ошибки и сообщение).
2. Сделать перехватчик-обработчик ошибок, который будет возвращать читаемую JSON-строку (в нашем случае - `RestApiExceptionsHandler`)

### Как понять, что должно быть на беке, что должно быть на фронте?

1. Данные всегда храним на беке
2. Безопасность реализуется и на беке и на фронте (какая-то ее часть на беке, какая-то часть на фронте)
3. Валидация данных (например, пустой пароль, кривой email и т.д.) делается и там и там
4. Фильтрации, сортировки, выборки, работа с большим количеством данных - всегда на беке.
5. В идеале - фронтэнд думает только о том, как это все красиво показать.

